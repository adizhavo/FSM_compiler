package FSMC

class CSharpVisitor extends LanguageVisitor {
  var file : String = ""
  var functions = List[String]()

  val OpenBrace = "{"
  val CloseBrace = "}"
  val CurrentState = "currentState"
  val ReceivedEvent = "receivedEvent"
  val ExecuteEntryFunction = "ExecuteEntryFunction"
  val ExecuteExitFunction = "ExecuteExitFunction"
  val state = "state"

  def FileExtension() : String = ".cs"

  def GenerateCode(codeNode : CodeGenerationNodes) : String = {
    if (codeNode == null) {
      println(Console.RED + "Passed null syntax node to the C# visitor" + Console.RESET)
      return ""
    }
    else {
      BuildClassDefinition(codeNode)
      AddCurrentState(codeNode)
      AddStateEnum(codeNode)
      BuildActionEnum(codeNode)
      BuildSwitchCaseStatement(codeNode)
      BuildEntryFunctionCaseStatement(codeNode)
      BuildExitFunctionCaseStatement(codeNode)
      BuildFunctions()
      EndFile()
      println(Console.GREEN + "File content generated by the C# visitor" + Console.RESET)
      return file
    }
  }

  private def BuildActionEnum(codeNode : CodeGenerationNodes) {
    file += "\tpublic enum " + codeNode.actionEnum.enumType + " " + OpenBrace + "\n"
    for (senum <- codeNode.actionEnum.values)
      file += "\t" + senum + ",\n"
    file += "\t" + CloseBrace + "\n"
  }

  private def BuildClassDefinition(codeNode : CodeGenerationNodes) {
    file += "public abstract class " + codeNode.header.fsm + OpenBrace + "\n\t"
  }

  private def AddCurrentState(codeNode : CodeGenerationNodes) {
    file += "public " + codeNode.stateEnum.enumType + " " + CurrentState + " = " + codeNode.stateEnum.enumType + "." + codeNode.header.initialState + ";\n\t"

    file += "private void SetState(" + codeNode.stateEnum.enumType + " newState)" + OpenBrace + "\n\t"
    file += ExecuteExitFunction + "(" + CurrentState + ");\n\t"
    file += CurrentState + " = newState;\n\t"
    file += ExecuteEntryFunction + "(newState);\n\t"
    file += CloseBrace + "\n\t"
  }

  private def AddStateEnum(codeNode : CodeGenerationNodes) {
    file += "public enum " + codeNode.stateEnum.enumType + OpenBrace + "\n"
    for (senum <- codeNode.stateEnum.values)
      file += "\t" + senum + ",\n"
    file += "\t" + CloseBrace + "\n"
  }

  private def BuildSwitchCaseStatement(codeNode : CodeGenerationNodes) {
    file += "\tpublic void SendEvent(" + codeNode.actionEnum.enumType + " " + ReceivedEvent + ")" + OpenBrace + "\n\t"

    // Check the current state first
    file += "switch(" + CurrentState + ")" + OpenBrace + "\n\t"
    for (_sn <- codeNode.switchNode.currentStateCaseNodes) {
      file += "case " + codeNode.stateEnum.enumType + "." + _sn.state + " :\n\t"

      // check the received event
      file += "\tswitch(" + ReceivedEvent + ")" + OpenBrace + "\n"
      for (_evnds <- _sn.eventCaseNodes) {
        file += "\t\tcase " + codeNode.actionEnum.enumType + "." + _evnds.event + " :\n"

        // build functions
        for (_f <- _evnds.functions) {
          if (_f != null) file += "\t\t" + _f.capitalize + "();\n"
          if (!functions.contains(_f))
            functions ::= _f
        }

        // change state
        file += "\t\tSetState(" + codeNode.stateEnum.enumType + "." + _evnds.nextState + ");\n"
        file += "\t\tbreak;\n"
      }
      file += "\t\t" + CloseBrace + "\n"
      file += "\tbreak;\n\t"
    }

    file += CloseBrace + "\n\t"

    file += CloseBrace + "\n"
  }

  private def BuildEntryFunctionCaseStatement(codeNode : CodeGenerationNodes) {
    file += "\tprivate void " + ExecuteEntryFunction + "(" + codeNode.stateEnum.enumType + " " + state + ")" + OpenBrace + "\n"
    file += "\t\tswitch(" + state + ")" + OpenBrace + "\n"
    for (_entryN <- codeNode.switchNode.entryFunctionCaseNodes) {
      if (_entryN.function != null) {
        file += "\t\tcase " + codeNode.stateEnum.enumType + "." + _entryN.state + ": " + _entryN.function.capitalize + "(); break;\n"
        functions ::= _entryN.function
      }
    }
    file += "\t\t" + CloseBrace + "\n\t" + CloseBrace + "\n"
  }

  private def BuildExitFunctionCaseStatement(codeNode : CodeGenerationNodes) {
    file += "\tprivate void " + ExecuteExitFunction + "(" + codeNode.stateEnum.enumType + " " + state + ")" + OpenBrace + "\n"
    file += "\t\tswitch(" + state + ")" + OpenBrace + "\n"
    for (_exitN <- codeNode.switchNode.exitFunctionCaseNodes) {
      if (_exitN.function != null) {
        file += "\t\tcase " + codeNode.stateEnum.enumType + "." + _exitN.state + ": " + _exitN.function.capitalize + "(); break;\n"
        functions ::= _exitN.function
      }
    }
    file += "\t\t" + CloseBrace + "\n\t" + CloseBrace + "\n"
  }

  private def BuildFunctions() {
    for (f <- functions)
      file += "\tprotected abstract void " + f.capitalize + "();\n"
  }

  private def EndFile() {
    file += CloseBrace + "\n"
  }
}
