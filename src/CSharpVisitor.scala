package FSMC

class CSharpVisitor extends LanguageVisitor {
  var file : String = ""
  var functions = List[String]()

  val OpenBrace = "{"
  val CloseBrace = "}"
  val Newline = "\n"
  val Tab = "\t"
  val CurrentState = "currentState"
  val ReceivedEvent = "receivedEvent"
  val ExecuteEntryFunction = "ExecuteEntryFunction"
  val ExecuteExitFunction = "ExecuteExitFunction"
  val state = "state"

  def FileExtension() : String = ".cs"

  def GenerateCode(codeNode : CodeGenerationNodes) : String = {
    if (codeNode == null) {
      println(Console.RED + "Passed null syntax node to the C# visitor" + Console.RESET)
      return ""
    }
    else {
      BuildClassDefinition(codeNode)
      AddCurrentState(codeNode)
      AddStateEnum(codeNode)
      BuildActionEnum(codeNode)
      BuildSwitchCaseStatement(codeNode)
      BuildEntryFunctionCaseStatement(codeNode)
      BuildExitFunctionCaseStatement(codeNode)
      BuildFunctions()
      EndFile()
      println(Console.GREEN + "File content generated by the C# visitor" + Console.RESET)
      return file
    }
  }

  private def BuildActionEnum(codeNode : CodeGenerationNodes) {
    file += Tab + "public enum " + codeNode.actionEnum.enumType + " " + OpenBrace + Newline
    for (senum <- codeNode.actionEnum.values)
      file += Tab + senum + "," + Newline
    file += Tab + CloseBrace + Newline
  }

  private def BuildClassDefinition(codeNode : CodeGenerationNodes) {
    file += "public abstract class " + codeNode.header.fsm + OpenBrace + Newline
  }

  private def AddCurrentState(codeNode : CodeGenerationNodes) {
    file += Tab + "public " + codeNode.stateEnum.enumType + " " + CurrentState + " = " + codeNode.stateEnum.enumType + "." + codeNode.header.initialState + ";" + Newline
    file += Tab + "private void SetState(" + codeNode.stateEnum.enumType + " newState)" + OpenBrace + Newline
    file += Tab + ExecuteExitFunction + "(" + CurrentState + ");" + Newline
    file += Tab + CurrentState + " = newState;" + Newline
    file += Tab + ExecuteEntryFunction + "(newState);" + Newline
    file += Tab + CloseBrace + Newline
  }

  private def AddStateEnum(codeNode : CodeGenerationNodes) {
    file += Tab + "public enum " + codeNode.stateEnum.enumType + OpenBrace + Newline
    for (senum <- codeNode.stateEnum.values)
      file += Tab + senum + "," + Newline
    file += Tab + CloseBrace + Newline
  }

  private def BuildSwitchCaseStatement(codeNode : CodeGenerationNodes) {
    file += Tab + "public void SendEvent(" + codeNode.actionEnum.enumType + " " + ReceivedEvent + ")" + OpenBrace + Newline

    // Check the current state first
    file += Tab + "switch(" + CurrentState + ")" + OpenBrace + Newline
    for (_sn <- codeNode.switchNode.currentStateCaseNodes) {
      file += Tab + "case " + codeNode.stateEnum.enumType + "." + _sn.state + " :" + Newline

      // check the received event
      file += Tab + Tab + "switch(" + ReceivedEvent + ")" + OpenBrace + Newline
      for (_evnds <- _sn.eventCaseNodes) {
        file += Tab + Tab + "case " + codeNode.actionEnum.enumType + "." + _evnds.event + " :" + Newline

        // build functions
        for (_f <- _evnds.functions) {
          if (_f != null) file += Tab + Tab + _f.capitalize + "();" + Newline
          if (!functions.contains(_f))
            functions ::= _f
        }

        // change state
        file += Tab + Tab + "SetState(" + codeNode.stateEnum.enumType + "." + _evnds.nextState + ");" + Newline
        file += Tab + Tab + "break;" + Newline
      }
      file += Tab + Tab + CloseBrace + Newline
      file += Tab + "break;" + Newline
    }

    file += Tab + CloseBrace + Newline

    file += Tab + CloseBrace + Newline
  }

  private def BuildEntryFunctionCaseStatement(codeNode : CodeGenerationNodes) {
    file += Tab + "private void " + ExecuteEntryFunction + "(" + codeNode.stateEnum.enumType + " " + state + ")" + OpenBrace + Newline
    file += Tab + Tab + "switch(" + state + ")" + OpenBrace + "\n"
    for (_entryN <- codeNode.switchNode.entryFunctionCaseNodes) {
      if (_entryN.function != null) {
        file += Tab + Tab + "case " + codeNode.stateEnum.enumType + "." + _entryN.state + ": " + _entryN.function.capitalize + "(); break;" + Newline
        functions ::= _entryN.function
      }
    }
    file += Tab + Tab + CloseBrace + Newline + Tab + CloseBrace + Newline
  }

  private def BuildExitFunctionCaseStatement(codeNode : CodeGenerationNodes) {
    file += Tab + "private void " + ExecuteExitFunction + "(" + codeNode.stateEnum.enumType + " " + state + ")" + OpenBrace + Newline
    file += Tab + Tab + "switch(" + state + ")" + OpenBrace + Newline
    for (_exitN <- codeNode.switchNode.exitFunctionCaseNodes) {
      if (_exitN.function != null) {
        file += Tab + Tab + "case " + codeNode.stateEnum.enumType + "." + _exitN.state + ": " + _exitN.function.capitalize + "(); break;" + Newline
        functions ::= _exitN.function
      }
    }
    file += Tab + Tab + CloseBrace + Newline + Tab + CloseBrace + Newline
  }

  private def BuildFunctions() {
    for (f <- functions)
      file += Tab + "protected abstract void " + f.capitalize + "();" + Newline
  }

  private def EndFile() {
    file += CloseBrace + Newline
  }
}
